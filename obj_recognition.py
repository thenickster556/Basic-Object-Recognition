# -*- coding: utf-8 -*-
"""obj_recognition_template.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KokubJNPrGMxHkidynq7h8cu7z6aGQse

Author: *your name*       <br/>
Python: *version*         <br/>
OpenCV: *version*
"""
import statistics
import cv2
import sys
# print("OpenCV: ", cv2.__version__)
# print("Python: ", sys.version)

# Here, we import the required libraries
import glob
from operator import itemgetter
import numpy as np
from matplotlib import pyplot as plt

# Load the Drive helper and mount
# from google.colab import drive

# This will prompt for authorization.
# drive.mount('/content/drive/')

# After executing the cell above, Store the images directory with the images 
# inside it in your notebook. Check the images with the below command
# !ls "/content/drive/My Drive/Colab Notebooks/assignment_2/images"

# Get all images
images = glob.glob("C:/Users/campb/OneDrive/robo sys/assignment 2/images/images/*.jpg")

# Create a class with the functions which are required to hold the processes that 
# need to be applied on the images.
class object_recognition():

    ''' Note: If query_img = None, take the path to dataset by deault, 
        else process single image.'''
    
    def matching(self, tempMeth,histMeth, query_input=None):
        final_matches_list = []
        if query_input is not None:
            queue_label = query
            queue_img = query_images_list
        else:
            queue_label = images
            queue_img = template_images_list
        
        #queue_img = cv2.cvtColor(queue_img, cv2.COLOR_BGR2GRAY)
        for i, inst in enumerate(queue_label):
            #Get the name of the image file without extension
            inst_match = {"query":inst.partition('/')[2].split('.')[0]}            
            all_matches_list =[]
            for j, tmp in enumerate(images):
              
                '''TODO: Apply template Matching'''
                
                res = cv2.matchTemplate(queue_img[i],template_images_list[j],tempMeth)
                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)
                # plt.subplot(121),plt.imshow(res,cmap = 'gray')
                # plt.title('Matching Result for '+ meth), plt.xticks([]), plt.yticks([])
                # plt.show()
                
                '''TODO: Apply color histogram. OpenCV function is faster 
                than (around 40X) than np.histogram(). So stick with OpenCV function.'''
                qHist = cv2.calcHist(queue_img[i],[0],None,[256],[0,255])
                tempHist = cv2.calcHist(template_images_list[j],[0],None,[256],[0,255])
                color_histogram = cv2.compareHist(qHist,tempHist, histMeth)

                '''TODO: Uncomment the below lines after writing your code to return the original list wit the differences values'''                               
                all_matches_list.append([tmp.partition('/')[2].split('.')[0], max_val, color_histogram])
                
            inst_match["all_matches"] = all_matches_list
            final_matches_list.append(inst_match)

        return final_matches_list

      
    '''Return a dictionary with the score values and the top 4 dictionary'''
    def scoring(self, match_result_list):

        sorted_scored_list ={}
        sortTemp =[]
        sortHist = []
        '''TODO: Create the scoring procedure'''
        for x in range(0,len(match_result_list)):
            attemptName = match_result_list[x]['all_matches']
            for i in attemptName:#seperating the values for template matching and histogram matching
                sortTemp.append([i[0],i[1]])
                sortHist.append([i[0],i[2]])
            sortTemp = sorted(sortTemp,key=lambda x: x[1],reverse=True) #appending the sorted arrays to return list
            sortHist= sorted(sortHist,key=lambda x: x[1],reverse=True)
            # for i in range(0,4):#putting names in a dictionary
            #     if i==0:
            sorted_scored_list[match_result_list[x]['query']+"hist"]= sortHist[:4]
            sorted_scored_list[match_result_list[x]['query']+"temp"] = sortTemp[:4]
            sortTemp=[]
            sortHist=[]
                # else:
                #     sorted_scored_list[match_result_list[x]['query']+"hist"].append(sortHist[i][0])
                #     sorted_scored_list[match_result_list[x]['query']+"temp"].append(sortTemp[i][0])

            
        return sorted_scored_list
    def string_split(self,string):
        ret = str(string.split('/')[len(string.split('/'))-1])#getting the end the stirng
        ret = str(ret.split('ukbench0')[1])#splitting off the beginning portion of the sting
        if ret.count('hist',0,len(ret)) == 1:#if this is in the sting
           ret = str(ret.split('hist')[0])
        #elif ret.find('temp') < 1:
        elif ret.count('temp', 0, len(ret)) == 1:
            ret = str(ret.split('temp')[0])
        return int(ret)
    def eval_cal(self, scoring_result):
        # remove pass after putting your code in the function
        #pass
        '''TODO: Calculate the mean'''
        count = 0
        mean_tm = 0.0
        mean_ch = 0.0
        for k,v in scoring_result.items():#getting items from dictionary
            for i in v:
                keyNum = self.string_split(k)
                valNum = self.string_split(i[0])
                count+=1
                if (keyNum-valNum >= (-3) and keyNum-valNum <= (3)) and k.count('temp')==1:#seeing if it  is
                    mean_tm +=1
                elif (keyNum-valNum >= (-3) and keyNum-valNum <= (3)) and k.count('hist')==1:
                    mean_ch+=1
        mean_ch = mean_ch/(len(scoring_result)*2)
        mean_tm = mean_tm/(len(scoring_result)*2)

        '''Uncomment the line below after'''
        return [["Template_match_mean", mean_tm], ["color_histogram_mean",mean_ch]]
    def printNames(self,arr):
        print("[",end='')
        for i in arr:
            print(str(i[0]),end=", ")
        print("]")
        return
# Main run
  
query_images_list = []
template_images_list = []

'''You can specify the image name in the query for testing. See example below'''
# query = ['C:/Users/campb/OneDrive/robo sys/assignment 2/images/images/ukbench00021.jpg',
# 'C:/Users/campb/OneDrive/robo sys/assignment 2/images/images/ukbench00285.jpg']
query = None

try:
    obj_rec = object_recognition()

    '''Run on query_img if argument passed, otherwise run on dataset'''
    if query != None:

        for query_img in query:
            query_images_list.append(cv2.imread(query_img, 0))

    for i in range(len(images)):
        template_images_list.append(cv2.imread(images[i], 0))

    tempMethods = ['cv2.TM_CCOEFF', 'cv2.TM_CCOEFF_NORMED', 'cv2.TM_CCORR',
        'cv2.TM_CCORR_NORMED', 'cv2.TM_SQDIFF', 'cv2.TM_SQDIFF_NORMED']
    histMethods = ['cv2.HISTCMP_CORREL','cv2.HISTCMP_CHISQR','cv2.HISTCMP_INTERSECT',
        'cv2.HISTCMP_BHATTACHARYYA']    
    namesCat = ['Duck','Chair','Lady','Picture','Playset']
    tempMethod = eval(tempMethods[0])
    histMethod = eval(histMethods[2])
    matching_results = obj_rec.matching(tempMethod,histMethod, query)
    sorted_scored_top4 = obj_rec.scoring(matching_results)
    evaluation_results = obj_rec.eval_cal(sorted_scored_top4)
    # print(sorted_scored_top4)
    idx=0
    queryCount =0
    namesCount =0
    smallSort={}#creating a smaller dict to store curr dictonary
    sdHist=[]
    sdTemp=[]
    for k,v in sorted_scored_top4.items():
        if idx%4==0 and namesCount<5:
            print(namesCat[namesCount])
            print
            namesCount+=1
        if idx%2==0:
            print("query: "+ images[queryCount] +"\n")
            queryCount+=1
            print
        
        # idx = sorted_scored_top4.keys().index(k)#getting index of key
        what=sorted_scored_top4.get(k)
        if k.count("hist")==1:# finding out what methood was used 
            print("top 4 colored histogram:")
            
        else:
            print("\ntop 4 template:")
        obj_rec.printNames(what)
        # print(what)
        print
        smallSort[k]=what#making the curr dictonary
        if idx%2!=0:
            num = obj_rec.eval_cal(smallSort)
            sdHist.append(num[0][1])
            sdTemp.append(num[1][1])
            print("for current query: "+str(num)+"\n")#printing the score of current dictonary
            smallSort={}
        idx+=1
    print
    print(dict(evaluation_results))
    print("standard deviation of Histogram matching: "+str(statistics.stdev(sdHist)))
    print("standard deviation of Template matching: "+str(statistics.stdev(sdTemp)))
    stdDevh= statistics.stdev(sdHist)
    stdDevt= statistics.stdev(sdTemp)
    things = ['Histogram',"Template"]
    x_pos = np.arange(len(things))
    CTEs= [0.75,0.72]
    stdDev = [stdDevh,stdDevt]

    fig, ax = plt.subplots()
    ax.bar(x_pos, CTEs, yerr=stdDev, align='center', alpha=0.5, ecolor='black', capsize=10)
    ax.set_ylabel('up')
    ax.set_xticks(x_pos)
    ax.set_xticklabels(things)
    ax.set_title('comparison')
    ax.yaxis.grid(True)

    # Save the figure and show
    plt.tight_layout()
    plt.savefig('the layout.png')
    plt.show()
except KeyboardInterrupt:
    print("Shutting down")

"""*Your output should look like below*
<br/>

. <br/>
. <br/>
. <br/>
class: duck    <br/>
query: content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench00021      <br/>
score_color_hist: #    <br/>
score_template_match: #      <br/>
top4_color_hist: ['content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench00021', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench00020', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench00023', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench09120']     <br/>

top4_template_match: ['content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench00021', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench00023', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench00287', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench00020']    <br/>
<br/>
class: photos    <br/>
query: content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench01492     <br/>
score_color_hist: #     <br/>
score_sift: #     <br/>
score_template_match: #     <br/>
top4_color_hist: ['content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench01492', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench01495', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench01494', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench01493']     <br/>

top4_template_match: ['content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench01492', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench01493', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench01495', 'content/drive/My Drive/Colab Notebooks/assignment_2/images/ukbench01494']     <br/>
. <br/>
. <br/>
. <br/>
<br/>

{'color_histogram_mean': ##, 'Template_match_mean': ##}
"""